[{"title":"Redis和Memcached比较","date":"2019-01-08T06:33:59.000Z","path":"2019/01/08/Redis和Memcached比较/","text":"Redis和Memcache都是将数据存放在内存中，都是内存数据库。本文介绍两者的区别。 Redis和Memcached比较 Memcached是多线程，而Redis使用单线程. Memcached使用预分配的内存池的方式，Redis使用现场申请内存的方式来存储数据，并且可以配置虚拟内存。 Redis可以实现持久化，主从复制，实现故障恢复。 Memcached只是简单的key与value,但是Redis支持数据类型比较多。 Redis的存储分为内存存储、磁盘存储 .从这一点，也说明了Redis与Memcached是有区别的。Redis 与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改 操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis有两种存储方式(默认:snapshot) snapshot 实现方法是定时将内存的快照(snapshot)持久化到硬盘，这种方法缺点是持久化之后如果出现crash则会丢失一段数据。因此在完美主义者的推动下作者增加了aof方式。 aof 即append only mode，在写入内存数据的同时将操作命令保存到日志文件，在一个并发更改上万的系统中，命令日志是一个非常庞大的数据，管理维护成本非常高，恢复重建时间会非常长，这样导致失去aof高可用性本意。另外更重要的是Redis是一个内存数据结构模型，所有的优势都是建立在对内存复杂数据结构高效的原子操作","tags":[{"name":"Redis","slug":"Redis","permalink":"https://wxzhongwang.github.io/tags/Redis/"},{"name":"NOSQL","slug":"NOSQL","permalink":"https://wxzhongwang.github.io/tags/NOSQL/"}]},{"title":"Redis简介","date":"2019-01-08T06:31:13.000Z","path":"2019/01/08/Redis简介/","text":"Redis是一个开源的，使用C语言编写，面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。Redis纯粹为应用而产生，它是一个高性能的key-value数据库,并且提供了多种语言的API，性能测试结果表示SET操作每秒钟可达110000次，GET操作每秒81000次（当然不同的服务器配置性能不同）。 RedisRedis是一个开源的，使用C语言编写，面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。Redis纯粹为应用而产生，它是一个高性能的key-value数据库,并且提供了多种语言的API，性能测试结果表示SET操作每秒钟可达110000次，GET操作每秒81000次（当然不同的服务器配置性能不同）。 Redis目前提供五种数据类型： string(字符串), list（链表）, Hash（哈希）, set（集合）, zset(sorted set) （有序集合） Redis开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。 Redis可以做消息队列？ 首先，redis设计用来做缓存的，但是由于它自身的某种特性使得它可以用来做消息队列，它有几个阻塞式的API可以使用，正是这些阻塞式的API让其有能力做消息队列；另外，做消息队列的其他特性例如FIFO（先入先出）也很容易实现，只需要一个list对象从头取数据，从尾部塞数据即可；redis能做消息队列还得益于其list对象blpop brpop接口以及Pub/Sub（发布/订阅）的某些接口，它们都是阻塞版的，所以可以用来做消息队列。 对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明： 入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。","tags":[{"name":"Redis","slug":"Redis","permalink":"https://wxzhongwang.github.io/tags/Redis/"},{"name":"消息队列","slug":"消息队列","permalink":"https://wxzhongwang.github.io/tags/消息队列/"}]},{"title":"Git使用中的问题","date":"2019-01-08T06:18:02.000Z","path":"2019/01/08/Git使用中的问题/","text":"git push失败 fatal: Could not read from remote repository 阐述问题git push失败 fatal: Could not read from remote repository. 因为仓库地址不对。更改地址就可以push了。 问题原因12$ git remote -v$ git remote set-url origin XXX 服务器上的 Git - 生成 SSH 公钥生成 SSH 公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。若想在github中使用的话需要将公钥复制到github&gt;setting&gt;SSH and GPG keys中添加ssh keys。 1234生成钥匙$ ssh-keygen查看公钥$cat ~/.ssh/id_rsa.pub","tags":[{"name":"Git","slug":"Git","permalink":"https://wxzhongwang.github.io/tags/Git/"}]},{"title":"HttpStatusCode","date":"2019-01-08T06:18:02.000Z","path":"2019/01/08/HttpStatusCode/","text":"HttpStatusCode12345678 /* 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误*/ 字段 状态码 说明 Continue 100 指示客户端可能继续其请求。 SwitchingProtocols 100 指示正在更改协议版本或协议。 OK 200 指示请求成功，且请求的信息包含在响应中。 Created 201 指示请求导致在响应被发送前创建新资源。 Accepted 202 指示请求已被接受做进一步处理。 NonAuthoritativeInformation 202 指示返回的元信息来自缓存副本而不是原始服务器，因此可能不正确。 NoContent 204 指示请求成功，指示已成功处理请求并且响应已被设定为无内容。 ResetContent 205 指示客户端应重置（或重新加载）当前资源。 PartialContent 206 指示响应是包括字节范围的 GET 请求所请求的部分响应。 MultipleChoices 300 指示请求的信息有多种表示形式，默认操作是将此状态视为重定向，并遵循与此响应关联的 Location 头的内容。 Ambiguous 300 指示请求的信息有多种表示形式。默认操作是将此状态视为重定向，并遵循与此响应关联的 Location 头的内容。 MovedPermanently 301 指示请求的信息已移到 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。 Moved 301 指示请求的信息已移到 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求将使用 GET 方法。 Found 302 指示请求的信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求将使用 GET 方法。 Redirect 302 指示请求的信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求将使用 GET 方法。 SeeOther 303 作为 POST 的结果，SeeOther 将客户端自动重定向到 Location 头中指定的 URI。用 GET 生成对 Location 头所指定的资源的请求。 RedirectMethod 303 作为 POST 的结果，RedirectMethod 将客户端自动重定向到 Location 头中指定的 URI。用 GET 生成对 Location 头所指定的资源的请求。 NotModified 304 指示客户端的缓存副本是最新的。未传输此资源的内容。 UseProxy 305 指示请求应使用位于 Location 头中指定的 URI 的代理服务器。 Unused 306 是未完全指定的 HTTP/1.1 规范的建议扩展。 TemporaryRedirect 307 指示请求信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求还将使用 POST 方法。 RedirectKeepVerb 307 指示请求信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求还将使用 POST 方法。 BadRequest 400 指示服务器未能识别请求。如果没有其他适用的错误，或者如果不知道准确的错误或错误没有自己的错误代码，则发送 BadRequest。 Unauthorized 401 指示请求的资源要求身份验证。WWW-Authenticate头包含如何执行身份验证的详细信息。 PaymentRequired 402 保留 PaymentRequired 以供将来使用。 Forbidden 403 指示服务器拒绝满足请求。 NotFound 404 指示请求的资源不在服务器上。 MethodNotAllowed 405 指示请求的资源上不允许请求方法（POST 或 GET）。 NotAcceptable 406 指示客户端已用 Accept 头指示将不接受资源的任何可用表示形式。 ProxyAuthenticationRequired 407 指示请求的代理要求身份验证。Proxy-authenticate 头包含如何执行身份验证的详细信息。 RequestTimeout 408 指示客户端没有在服务器期望请求的时间内发送请求。 Conflict 409 指示由于服务器上的冲突而未能执行请求。 Gone 410 指示请求的资源不再可用。 LengthRequired 411 指示缺少必需的 Content-length 头。 PreconditionFailed 412 指示为此请求设置的条件失败，且无法执行此请求。条件是用条件请求标头（如 If-Match、If-None-Match 或 If-Unmodified-Since）设置的。 RequestEntityTooLarge 413 指示请求太大，服务器无法处理。 RequestUriTooLong 414 指示 URI 太长。 UnsupportedMediaType 415 指示请求是不支持的类型。 RequestedRangeNotSatisfiable 416 RequestedRangeNotSatisfiable指示无法返回从资源请求的数据范围，因为范围的开头在资源的开头之前，或因为范围的结尾在资源的结尾之后。 ExpectationFailed 417 指示服务器未能符合 Expect 头中给定的预期值。 UpgradeRequired 426 客户端应当切换到TLS/1.0 InternalServerError 500 指示服务器上发生了一般错误。 NotImplemented 501 指示服务器不支持请求的函数。 BadGateway 502 指示中间代理服务器从另一代理或原始服务器接收到错误响应。 ServiceUnavailable 503 指示服务器暂时不可用，通常是由于过多加载或维护。 GatewayTimeout 504 指示中间代理服务器在等待来自另一个代理或原始服务器的响应时已超时。 HttpVersionNotSupported 505 指示服务器不支持请求的 HTTP 版本。","tags":[{"name":"Web","slug":"Web","permalink":"https://wxzhongwang.github.io/tags/Web/"},{"name":"前端","slug":"前端","permalink":"https://wxzhongwang.github.io/tags/前端/"}]},{"title":"你好，世界","date":"2018-08-31T09:54:54.000Z","path":"2018/08/31/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"前端","slug":"前端","permalink":"https://wxzhongwang.github.io/tags/前端/"},{"name":"博客系统","slug":"博客系统","permalink":"https://wxzhongwang.github.io/tags/博客系统/"}]}]