<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我喜欢你喜欢我的歌</title>
  
  <subtitle>Dick</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wxzhongwang.github.io/"/>
  <updated>2019-02-25T02:49:48.918Z</updated>
  <id>https://wxzhongwang.github.io/</id>
  
  <author>
    <name>Dick Zhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Greenplum 从入门到放弃（四）</title>
    <link href="https://wxzhongwang.github.io/2019/02/04/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/04/Greenplum 从入门到放弃（四）/</id>
    <published>2019-02-04T02:10:00.000Z</published>
    <updated>2019-02-25T02:49:48.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（四）"><a href="#Greenplum-从入门到放弃（四）" class="headerlink" title="Greenplum 从入门到放弃（四）"></a>Greenplum 从入门到放弃（四）</h1><h2 id="PostgreSQL与Greenplum的关系"><a href="#PostgreSQL与Greenplum的关系" class="headerlink" title="PostgreSQL与Greenplum的关系"></a>PostgreSQL与Greenplum的关系</h2><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><p>PostgreSQL是一种非常先进的对象–关系型数据库管理系统（ORDBMS），是目前功能最强大，特性最丰富和技术最先进的自由软件数据库系统之一，其某些特性甚至连商业数据库都不具备。</p><p>PostgreSQL的特点可以说是数不胜数，称其为最先进的开<br>源软件数据库当之无愧，支持绝大部分的主流数据库特性，主<br>要体现在如下几方面：</p><ol><li>函数/存储过程</li></ol><p>PostgreSQL对非常丰富的过程类语言提供支持，可以编写自定义函数/存储过程</p><ul><li>内置的plpgsql，一种类似Oracle的PLsql的语言</li><li>支持的脚本语言有：PL/Lua、PL/LOLCODE、PL/Perl、PL/HP、PL/Python、PL/Ruby、PL/sh、PL/Tcl和PL/Scheme。、</li><li>编译语言有C、C++和JAVA。</li><li>·统计语言PL/R</li></ul><ol start="2"><li>索引</li></ol><p>PostgreSQL支持用户定义的索引访问方法，并且内置了Btree、哈希和GiST索引。PostgreSQL中的索引有下面几个特点：</p><ul><li>可以从后向前扫描</li><li>可以创建表达式索引</li><li>部分索引</li></ul><ol start="3"><li>触发器</li></ol><p>触发器是由SQL查询的动作触发的事件。比如，一个INSERT查询可能激活一个检查输入值是否有效的触发器。大多数触发器都只对INSERT或者UPDATE查询有效。PostgreSQL完全支持触发器，可以附着在表上，但是不能在视图上。不过视图可以有规则。多个触发器是按照字母顺序触发的。我们还可以用其他过程语言书写触发器函数，不仅仅PL/PgSQL。</p><ol start="4"><li>并发管理（MVCC）</li></ol><p>PostgreSQL的并发管理使用的是一种叫做“MVCC”（多版本并发机制）的机制，这种机制实际上就是现在在众多所谓的编程语言中极其火爆的“Lock Free”，其本质是通过类似科幻世界的时空穿梭的原理，给予每个用户一个自己的“时空”<br>，然后通过原子的“时空”控制来控制时间基线，并以此控制并发更改的可见区域，从而实现近乎无锁的并发，而同时还能在很大程度上保证数据库的ACID特性。</p><ol start="5"><li>规则（RULE）</li></ol><p>规则允许我们对由一个查询生成的查询树进行改写。</p><ol start="6"><li>数据类型</li></ol><p>PostgreSQL支持非常广泛的数据类型，包括：</p><ul><li>任意精度的数值类型；</li><li>无限长度的文本类型；</li><li>几何原语；</li><li>IPv4和IPv6类型；</li><li>CIDR块和MAC地址；</li><li>数组。</li></ul><p>用户还可以创建自己的类型，并且可以利用GiST框架把这些类型做成完全可索引的，比如来自PostGIS的地理信息系统（GIS）的数据类型。</p><ol start="7"><li>用户定义对象</li></ol><p>因为PostgreSQL使用一种基于系统表的可扩展的结构设计，所以PostgreSQL内部的几乎所有对象都可以由用户定义，这些对象包括：</p><ul><li>索引；</li><li>操作符（内部操作符可以被覆盖）；</li><li>聚集函数；</li><li>域；</li><li>类型转换；</li><li>编码转换。</li></ul><ol start="8"><li>继承</li></ol><p>PostgreSQL的表是可以相互继承的。一个表可以有父表，<br>父表的结构变化会导致子表的结构变化，而对子表的插入和数<br>据更新等也会反映到父表中。</p><ol start="9"><li>其他特性与扩展</li></ol><ul><li>二进制和文本大对象存储；</li><li>在线备份；</li><li>TOAST（The Oversized-Attribute Storage Technique）用于透明地在独立的地方保存大的数据库属性，当数据超过一定大小的时候，会自动进行压缩以节省空间；</li><li>正则表达式。</li></ul><p>此外PostgreSQL还有大量的附加模块和扩展版本，比如，多种不同的主从/主主复制方案:</p><ul><li>Slony-I；</li><li>pgcluster；</li><li>Mammoth replicator；</li><li>Bucardo。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（四）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（四）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（四）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（四）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃（三）</title>
    <link href="https://wxzhongwang.github.io/2019/02/03/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/03/Greenplum 从入门到放弃（三）/</id>
    <published>2019-02-03T02:10:00.000Z</published>
    <updated>2019-02-25T02:49:36.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（三）"><a href="#Greenplum-从入门到放弃（三）" class="headerlink" title="Greenplum 从入门到放弃（三）"></a>Greenplum 从入门到放弃（三）</h1><h2 id="master-和-segment关系"><a href="#master-和-segment关系" class="headerlink" title="master 和 segment关系"></a>master 和 segment关系</h2><p>Master和Segment其实都是一个单独的PostgreSQL数据库。<br>每一个都有自己单独的一套元数据字典，在这里，Master节点<br>一般也叫主节点，Segment也叫做数据节点。<br>Segment节点与Master节点的通信，通过千兆（或万兆）<br>网卡组成的内部连接（InterConnect），在同一台数据节点机<br>器上可以放多个Segment，不同的Segment节点会被赋予不同的<br>端口，同时，Segment之间也不断地进行着交互。为了实现高<br>可用，每个Segment都有对应的备节点（Mirror Segment），分<br>别存在于不同的机器上。</p><blockquote><p>Client一般只能与Master节点进行交互，Client将SQL发给Master，然后Master对SQL进行分析后，再将其分配给所有的Segment进行操作，并且将汇总结果返回给客户端。</p></blockquote><h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>对于数据库来说，在性能上磁盘IO很容易成为瓶颈，由于数据库的特性，每一个SQL基本都是对全表数据进行分析，每次处理的数据量非常大，数据基本上都是没有缓存的（数据字典除外），极度消耗IO资源（全表扫描主要都是顺序IO），所以Greenplum对存储的要求比较高。在文件系统的选择上，在Linux下建议使用XFS，在Solaris下建议使用ZFS，对于Raid根据需求选择硬Raid或软Raid，如果需要更大的空间，建议使用Raid5，如果对性能有更高的要求，可以选择Raid 1+0。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在确定机器配置的时候，要保证所有机器的网络都是通的，并且每台机器的防火墙都是关闭的，避免存在网络不通的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（三）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（三）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（三）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（三）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃（二）</title>
    <link href="https://wxzhongwang.github.io/2019/02/02/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/02/Greenplum 从入门到放弃（二）/</id>
    <published>2019-02-02T02:10:00.000Z</published>
    <updated>2019-02-25T02:49:42.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（二）"><a href="#Greenplum-从入门到放弃（二）" class="headerlink" title="Greenplum 从入门到放弃（二）"></a>Greenplum 从入门到放弃（二）</h1><h2 id="OLTP与OLAP"><a href="#OLTP与OLAP" class="headerlink" title="OLTP与OLAP"></a>OLTP与OLAP</h2><p>数据库系统一般分为两种类型，一种是面向前台应用的，应用比较简单，但是重吞吐和高并发的OLTP类型；一种是重计算的，对大数据集进行统计分析的OLAP类型。Greenplum属于后者。</p><p>OLTP（On-Line Transaction<br>Processing，联机事务处理）系统也称为生产系统，它是事件驱动的、面向应用的，比如电<br>子商务网站的交易系统就是一个典型的OLTP系统。OLTP的基本特点是：</p><ul><li>数据在系统中产生</li><li>基于交易的处理系统（Transaction-Based）</li><li>每次交易牵涉的数据量很小</li><li>对响应时间要求非常高</li><li>用户数量非常庞大，主要是操作人员</li><li>数据库的各种操作主要基于索引进行</li></ul><p>OLAP（On-Line Analytical Processing，联机分析处理）是基于数据仓库的信息分析处理过程，是数据仓库的用户接口部分。OLAP系统是跨部门的、面向主题的，其基本特点是：</p><ul><li>本身不产生数据，其基础数据来源于生产系统中的操作数据（OperationalData）</li><li>基于查询的分析系统</li><li>复杂查询经常使用多表联结、全表扫描等，牵涉的数据量往往十分庞大</li><li>响应时间与具体查询有很大关系</li><li>用户数量相对较小，其用户主要是业务人员与管理人员</li><li>由于业务问题不固定，数据库的各种操作不能完全基于索引进行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（二）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（二）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（二）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（二）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃（一）</title>
    <link href="https://wxzhongwang.github.io/2019/02/01/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/01/Greenplum 从入门到放弃（一）/</id>
    <published>2019-02-01T02:10:00.000Z</published>
    <updated>2019-02-25T02:49:30.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（一）"><a href="#Greenplum-从入门到放弃（一）" class="headerlink" title="Greenplum 从入门到放弃（一）"></a>Greenplum 从入门到放弃（一）</h1><ul><li><p>Greenplum的性能在数据量为TB级别时表现非常优秀，单机性能相比Hadoop要快好几倍</p></li><li><p>Greenplum是基于PostgreSQL的一个完善的数据库，在功能和语法上都要比Hadoop上的SQL引擎Hive好用很多，对于普通用户来说更加容易上手。</p></li><li><p>Greenplum有着完善的工具，相比Hive，整个体系都比较完善，不需要像Hive一样花太多的时间和精力进行改造，非常适合作为一些大型的数据仓库解决方案。</p></li><li><p>Greenplum能够方便地与Hadoop进行结合，可直接把数据写在Hadoop上，还可以直接在数据库上写MapReduce任务，并且配置简单。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（一）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（一）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（一）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（一）&lt;/h1&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Java VM 1.0</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/1.0%20Java%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/1.0 Java程序执行流程/</id>
    <published>2019-01-30T08:55:20.159Z</published>
    <updated>2019-01-30T08:59:27.343Z</updated>
    
    <content type="html"><![CDATA[<p>1.Java程序执行流程</p><p>Java技术的核心就是Java虚拟机，因为所有的Java程序都在虚拟机上运行。Java程序的运行需要Java虚拟机、Java API和Java Class文件的配合。Java虚拟机实例负责运行一个Java程序。当启动一个Java程序时，一个虚拟机实例就诞生了。当程序结束，这个虚拟机实例也就消亡。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java3-1547432465.jpg" alt="image"></p><p>分为编译时环境和运行时环境，很基础很重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Java程序执行流程&lt;/p&gt;
&lt;p&gt;Java技术的核心就是Java虚拟机，因为所有的Java程序都在虚拟机上运行。Java程序的运行需要Java虚拟机、Java API和Java Class文件的配合。Java虚拟机实例负责运行一个Java程序。当启动一个Java程序时
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wxzhongwang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java VM 2.0</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/2.0%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/2.0 Java虚拟机/</id>
    <published>2019-01-30T08:55:16.884Z</published>
    <updated>2019-01-30T08:56:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>#Java虚拟机</p><p>作用：</p><blockquote><p>Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器（class loader），它可以从程序和API中装载class文件，Java API中只有程序执行时需要的类才会被装载，字节码由执行引擎来执行。</p></blockquote><p>当Java虚拟机由主机操作系统上的软件实现时，Java程序通过调用本地方法和主机进行交互。Java方法由Java语言编写，编译成字节码，存储在class文件中。本地方法由C/C++/汇编语言编写，编译成和处理器相关的机器代码，存储在动态链接库中，格式是各个平台专有。所以本地方法是联系Java程序和底层主机操作系统的连接方式。（跨平台）</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java8-1547432465.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Java虚拟机&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器（class loader），它可以从程序和API中装载class文件，Java API中只有程序
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wxzhongwang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java VM 4.0</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/4.0%20Class%E6%96%87%E4%BB%B6/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/4.0 Class文件/</id>
    <published>2019-01-30T08:55:14.146Z</published>
    <updated>2019-01-30T08:56:51.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符号。Class文件采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只包含两种数据类型，无符号数和表。无符号数属于基本的数据类型，以u1,u2,u4,u8分别代表1个字节，2个字节，4个字节和8个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照utf-8编码构成字符串值。表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾，用来描述有层次关系的复合结构数据。</p><p>Class文件的内容包括：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ClassFile</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="selector-tag">u4</span> <span class="selector-tag">magic</span>;                                     <span class="comment">//魔数：0xCAFEBABE，用来判断是否是Java class文件</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">minor_version</span>;                             <span class="comment">//次版本号</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">major_version</span>;                             <span class="comment">//主版本号</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">constant_pool_count</span>;                       <span class="comment">//常量池大小</span></span><br><span class="line">   <span class="selector-tag">cp_info</span> <span class="selector-tag">constant_pool</span><span class="selector-attr">[constant_pool_count-1]</span>; <span class="comment">//常量池</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">access_flags</span>;                              <span class="comment">//类和接口层次的访问标志（通过|运算得到）</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">this_class</span>;                                <span class="comment">//类索引（指向常量池中的类常量）</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">super_class</span>;                               <span class="comment">//父类索引（指向常量池中的类常量）</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">interfaces_count</span>;                          <span class="comment">//接口索引计数器</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">interfaces</span><span class="selector-attr">[interfaces_count]</span>;              <span class="comment">//接口索引集合</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">fields_count</span>;                              <span class="comment">//字段数量计数器</span></span><br><span class="line">   <span class="selector-tag">field_info</span> <span class="selector-tag">fields</span><span class="selector-attr">[fields_count]</span>;              <span class="comment">//字段表集合</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">methods_count</span>;                             <span class="comment">//方法数量计数器</span></span><br><span class="line">   <span class="selector-tag">method_info</span> <span class="selector-tag">methods</span><span class="selector-attr">[methods_count]</span>;           <span class="comment">//方法表集合</span></span><br><span class="line">   <span class="selector-tag">u2</span> <span class="selector-tag">attributes_count</span>;                          <span class="comment">//属性个数</span></span><br><span class="line">   <span class="selector-tag">attribute_info</span> <span class="selector-tag">attributes</span><span class="selector-attr">[attributes_count]</span>;  <span class="comment">//属性表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问标志：类还是接口；是否定义为public类型，abstract类型；若为类，是否声明为final。</li><li>字段：用来描述接口或类中的变量，但不包括在方法内部的变量。</li><li>字面量：文本字符串，声明为final的常量值等。</li><li>符号引用：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符。</li><li>类索引，父类索引，接口索引：用来确定类的继承关系。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Class文件&quot;&gt;&lt;a href=&quot;#Class文件&quot; class=&quot;headerlink&quot; title=&quot;Class文件&quot;&gt;&lt;/a&gt;Class文件&lt;/h1&gt;&lt;p&gt;Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wxzhongwang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java VM 3.0</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/3.0%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E9%83%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/3.0 Java虚拟机的内部体系结构/</id>
    <published>2019-01-30T08:55:10.612Z</published>
    <updated>2019-01-30T08:56:33.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机的内部体系结构"><a href="#Java虚拟机的内部体系结构" class="headerlink" title="Java虚拟机的内部体系结构"></a>Java虚拟机的内部体系结构</h1><p>在 Java虚拟机规范中，一个虚拟机实例的行为是分别按照子系统、内存区、数据类型和指令来描述的，这些组成部分一起展示了抽象的虚拟机内部体系结构。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java3-1547432465-1.jpg" alt="image"></p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>Java虚拟机在执行Java程序的时候会把它管理的内存划分为若干个不同的数据区域，这些区域有各自的用途以及创建和销毁的时机，有的区域随着虚拟机进程的启动而存在（线程共享），有的区域则随着用户线程的启动和结束而建立和销毁（线程私有）。Java虚拟机所管理的内存包括以下几个运行时数据区域。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>对于一个运行中的Java程序而言，每一个线程都有它的程序计数器，也叫PC寄存器，可以看做当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等都需要依赖这个计数器。</p><p>程序计数器既能持有一个本地指针，也能持有一个returnAddress。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。这里的地址可以是一个本地指针，也可以是方法字节码中相对该方法起始指令的偏移量。如果该线程正在执行一个本地方法，那么此时程序计数器的值是“undefined”。</p><p>程序计数器属于线程私有的内存，也就是说，每当创建一个线程，都将得到该线程自己的一个程序计数器。Java虚拟机的多线程是通过线程的轮换并且分配处理器的执行时间来实现的，在一个确定的时刻，一个处理器都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p><h3 id="Java虚拟机栈（Java栈）"><a href="#Java虚拟机栈（Java栈）" class="headerlink" title="Java虚拟机栈（Java栈）"></a>Java虚拟机栈（Java栈）</h3><p>Java虚拟机栈也是线程私有的，它的生命周期和线程相同。Java虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行时会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。一个Java方法从调用到执行结束的过程，相当于一个栈帧在Java虚拟机栈中从入栈到出栈的过程。<br>（1）局部变量表<br>局部变量表用于存放编译时期可知的各种基本数据类型，对象的引用（不等同于对象，可能是指向对象的起始地址的指针，也可能是指向一个代表对象的句柄）以及returnAddress类型（指向了一条字节码地址）。局部变量在方法执行时被创建，在方法执行结束时销毁。</p><p>字节码指令通过从0开始的索引使用其中的数据。类型为int, float, reference和returnAddress的值在数组中占据一项，而类型为byte, short和char的值在存入数组前都被转换为int值，也占据一项。但类型为long和double的值在数组中却占据连续的两项。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。它通过标准的栈操作访问–压栈和出栈。由于程序计数器无法被程序指令直接访问，Java虚拟机的指令是从操作数栈中取得操作数，所以它的运行方式是基于栈而不是基于寄存器。虚拟机把操作数栈作为它的工作区，因为大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。</p><h3 id="帧数据区"><a href="#帧数据区" class="headerlink" title="帧数据区"></a>帧数据区</h3><p>除了局部变量区和操作数栈，Java栈帧还需要帧数据区来支持常量池解析、正常方法返回以及异常派发机制。每当虚拟机要执行某个需要用到常量池数据的指令时，它会通过帧数据区中指向常量池的指针来访问它。除了常量池的解析外，帧数据区还要帮助虚拟机处理Java方法的正常结束或异常中止。如果通过return正常结束，虚拟机必须恢复发起调用的方法的栈帧，包括设置程序计数器指向发起调用方法的下一个指令；如果方法有返回值，虚拟机需要将它压入到发起调用的方法的操作数栈。为了处理Java方法执行期间的异常退出情况，帧数据区还保存一个对此方法异常表的引用。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>任何本地方法接口都会使用某种本地方法栈，本地方法栈与Java虚拟机栈发挥的作用类似。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中，堆是虚拟机管理的内存最大的一块，被所有线程所共享，在虚拟机启动的时候创建。堆内存的唯一目的就是存放对象实例，几乎所有的对象实例都在堆中分配内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同Java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量以及及时编译器编译后的代码等信息。当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件并将它传输到虚拟机中，接着虚拟机提取其中的类型信息，并将这些信息存储到方法区。方法区也可以被垃圾回收器收集，因为虚拟机允许通过用户定义的类装载器来动态扩展Java程序。</p><p>方法区中存放了以下信息：</p><pre><code>• 这个类型的全限定名（如全限定名java.lang.Object）• 这个类型的直接超类的全限定名• 这个类型是类类型还是接口类型• 这个类型的访问修饰符（public, abstract, final的某个子集）• 任何直接超接口的全限定名的有序列表• 该类型的常量池，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，用于存放编译时生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放• 字段信息（字段名、类型、修饰符）• 方法信息（方法名、返回类型、参数数量和类型、修饰符）• 除了常量以外的所有类（静态）变量• 指向ClassLoader类的引用（每个类型被装载时，虚拟机必须跟踪它是由启动类装载器还是由用户自定义类装载器装载的）• 指向Class类的引用（对于每一个被装载的类型，虚拟机相应地为它创建一个java.lang.Class类的实例存于堆中。比如你有一个到java.lang.Integer类的对象的引用，那么只需要调用Integer对象引用的getClass()方法，就可以得到表示java.lang.Integer类的Class对象）</code></pre><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>虚拟机把Java描述类的信息加载到内存，并对数据进行校验，转换解析和初始化，形成可以被Java虚拟机直接使用的Java类型，这就是Java虚拟机的类加载机制。类从加载到虚拟机开始，到卸载出内存为止，它的整个生命周期包括：</p><blockquote><p>加载，验证，准备，解析，初始化，使用和卸载7个阶段。</p></blockquote><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/01/java2-1547432466.png" alt="image"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载的一个阶段，在该阶段，Java虚拟机主要完成以下三件事情：</p><pre><code>• 根据此类的全限定名来确定该类的二进制字节流；• 将这个字节流所代表的静态数据存储结构转换为方法区的运行时数据结构；• 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息是否符合该虚拟机的要求。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段正式为类变量在方法区中分配内存并且赋初始值，初始值一般为该类变量类型的零值。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段虚拟机将常量池内的符号引用替换为直接引用。<br>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。<br>直接引用：是指能直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载过程的最后一个阶段，在前面的类加载过程中，除了在加载阶段用户可以自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化阶段，才真正开始执行类中定义的Java代码（字节码）。准备阶段为类变量分配内存并且赋初始值，赋值操作在初始化阶段执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java虚拟机的内部体系结构&quot;&gt;&lt;a href=&quot;#Java虚拟机的内部体系结构&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机的内部体系结构&quot;&gt;&lt;/a&gt;Java虚拟机的内部体系结构&lt;/h1&gt;&lt;p&gt;在 Java虚拟机规范中，一个虚拟机实例的行
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wxzhongwang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker初探1.0</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/Docker基本命令/</id>
    <published>2019-01-30T08:54:02.318Z</published>
    <updated>2019-01-30T08:54:40.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从公网拉取一个镜像</span><br><span class="line">docker pull images_name</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看已有的docker镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看帮助</span><br><span class="line">docker <span class="built_in">command</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看容器的端口映射情况</span><br><span class="line">docker<span class="built_in"> port </span>con_id</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看正在运行的容器</span><br><span class="line">docker <span class="keyword">ps</span></span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看所有的容器</span><br><span class="line">docker ps -<span class="keyword">a</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker命令&quot;&gt;&lt;a href=&quot;#Docker命令&quot; class=&quot;headerlink&quot; title=&quot;Docker命令&quot;&gt;&lt;/a&gt;Docker命令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Docker" scheme="https://wxzhongwang.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://wxzhongwang.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Git 远程仓库</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/Git%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/Git 远程仓库/</id>
    <published>2019-01-30T08:42:39.563Z</published>
    <updated>2019-01-30T08:43:25.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h1><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。</p><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>如果想查看你已经配置的远程仓库服务器，可以运行 <strong>git remote</strong> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone git<span class="variable">@172</span>.<span class="number">16.5</span>.<span class="number">77</span><span class="symbol">:shengwangzhong/storelcoator</span>.git</span><br><span class="line">Cloning into <span class="string">'storelcoator'</span>...</span><br><span class="line"><span class="symbol">remote:</span> Reusing existing <span class="symbol">pack:</span> <span class="number">1857</span>, done.</span><br><span class="line"><span class="symbol">remote:</span> Total <span class="number">1857</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Receiving <span class="symbol">objects:</span> <span class="number">100</span>% (<span class="number">1857</span>/<span class="number">1857</span>), <span class="number">374.35</span> KiB | <span class="number">268.00</span> KiB/s, done.</span><br><span class="line">Resolving <span class="symbol">deltas:</span> <span class="number">100</span>% (<span class="number">772</span>/<span class="number">772</span>), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="variable">$ </span>cd storelcoator</span><br><span class="line"><span class="variable">$ </span>git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></p><p>你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line">origin  git<span class="variable">@172</span>.<span class="number">16.5</span>.<span class="number">77</span><span class="symbol">:shengwangzhong/vue-myblog</span>.git (fetch)</span><br><span class="line">origin  git<span class="variable">@172</span>.<span class="number">16.5</span>.<span class="number">77</span><span class="symbol">:shengwangzhong/vue-myblog</span>.git (push)</span><br></pre></td></tr></table></figure></p><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  <span class="string">https:</span><span class="comment">//github.com/bakkdoor/grit (fetch)</span></span><br><span class="line">bakkdoor  <span class="string">https:</span><span class="comment">//github.com/bakkdoor/grit (push)</span></span><br><span class="line">cho45     <span class="string">https:</span><span class="comment">//github.com/cho45/grit (fetch)</span></span><br><span class="line">cho45     <span class="string">https:</span><span class="comment">//github.com/cho45/grit (push)</span></span><br><span class="line">defunkt   <span class="string">https:</span><span class="comment">//github.com/defunkt/grit (fetch)</span></span><br><span class="line">defunkt   <span class="string">https:</span><span class="comment">//github.com/defunkt/grit (push)</span></span><br><span class="line">koke      <span class="string">git:</span><span class="comment">//github.com/koke/grit.git (fetch)</span></span><br><span class="line">koke      <span class="string">git:</span><span class="comment">//github.com/koke/grit.git (push)</span></span><br><span class="line">origin    git<span class="meta">@github</span>.<span class="string">com:</span>mojombo/grit.git (fetch)</span><br><span class="line">origin    git<span class="meta">@github</span>.<span class="string">com:</span>mojombo/grit.git (push)</span><br></pre></td></tr></table></figure></p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote <span class="built_in">add</span> pb http<span class="variable">s:</span>//github.<span class="keyword">com</span>/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttp<span class="variable">s:</span>//github.<span class="keyword">com</span>/schacon/ticgit (fetch)</span><br><span class="line">originhttp<span class="variable">s:</span>//github.<span class="keyword">com</span>/schacon/ticgit (push)</span><br><span class="line">pbhttp<span class="variable">s:</span>//github.<span class="keyword">com</span>/paulboone/ticgit (fetch)</span><br><span class="line">pbhttp<span class="variable">s:</span>//github.<span class="keyword">com</span>/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure></url></shortname></p><p>现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line"><span class="string">remote:</span> Counting <span class="string">objects:</span> <span class="number">43</span>, done.</span><br><span class="line"><span class="string">remote:</span> Compressing <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">36</span>/<span class="number">36</span>), done.</span><br><span class="line"><span class="string">remote:</span> Total <span class="number">43</span> (delta <span class="number">10</span>), reused <span class="number">31</span> (delta <span class="number">5</span>)</span><br><span class="line">Unpacking <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">43</span>/<span class="number">43</span>), done.</span><br><span class="line">From <span class="string">https:</span><span class="comment">//github.com/paulboone/ticgit</span></span><br><span class="line"> * [<span class="keyword">new</span> branch]      master     -&gt; pb/master</span><br><span class="line"> * [<span class="keyword">new</span> branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure></p><p>现在 Paul 的 master 分支可以在本地通过 pb/master 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 </p><h2 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h2><p>就如刚才所见，从远程仓库中获得数据，可以执行：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch <span class="string">[remote-name]</span></span><br></pre></td></tr></table></figure></p><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><blockquote><p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p></blockquote><blockquote><p>如果你有一个分支设置为跟踪一个远程分支，可以使用 <strong>git pull</strong> 命令来自动的抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程；==默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。== 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p></blockquote><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure></p><blockquote><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 </p></blockquote><h2 id="查看远程仓库-详细"><a href="#查看远程仓库-详细" class="headerlink" title="查看远程仓库(详细)"></a>查看远程仓库(详细)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="keyword">show</span> origin</span><br><span class="line">* remote origin</span><br><span class="line">  <span class="keyword">Fetch</span> <span class="keyword">URL</span>: git@<span class="number">172.16</span><span class="number">.5</span><span class="number">.77</span>:shengwangzhong/vue-myblog.git</span><br><span class="line">  Push  <span class="keyword">URL</span>: git@<span class="number">172.16</span><span class="number">.5</span><span class="number">.77</span>:shengwangzhong/vue-myblog.git</span><br><span class="line">  <span class="keyword">HEAD</span> branch: <span class="keyword">master</span></span><br><span class="line">  Remote branch:</span><br><span class="line">    <span class="keyword">master</span> tracked</span><br><span class="line">  <span class="keyword">Local</span> branch configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span><br><span class="line">    <span class="keyword">master</span> merges <span class="keyword">with</span> remote <span class="keyword">master</span></span><br><span class="line">  <span class="keyword">Local</span> <span class="keyword">ref</span> configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span><br><span class="line">    <span class="keyword">master</span> pushes <span class="keyword">to</span> <span class="keyword">master</span> (up <span class="keyword">to</span> <span class="built_in">date</span>)</span><br></pre></td></tr></table></figure><p>这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。</p><h2 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h2><p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote rename pb paul</span><br><span class="line"><span class="variable">$ </span>git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-远程仓库&quot;&gt;&lt;a href=&quot;#Git-远程仓库&quot; class=&quot;headerlink&quot; title=&quot;Git 远程仓库&quot;&gt;&lt;/a&gt;Git 远程仓库&lt;/h1&gt;&lt;p&gt;为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 撤销操作</title>
    <link href="https://wxzhongwang.github.io/2019/01/30/Git%20%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://wxzhongwang.github.io/2019/01/30/Git 撤销操作/</id>
    <published>2019-01-30T08:42:35.376Z</published>
    <updated>2019-01-30T08:43:03.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-撤销操作"><a href="#Git-撤销操作" class="headerlink" title="Git 撤销操作"></a>Git 撤销操作</h1><p>在任何一个阶段，你都有可能想要撤消某些操作。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure></p><p>这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">'initial commit'</span></span><br><span class="line">$ git <span class="keyword">add</span> forgotten_file</span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure></p><p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p><h2 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h2><p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git add *</span><br><span class="line"><span class="variable">$ </span>git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be <span class="symbol">committed:</span></span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    <span class="symbol">renamed:</span>    README.md -&gt; README</span><br><span class="line">    <span class="symbol">modified:</span>   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p><p>在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD <file>… 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> CONTRIBUTING.md</span><br><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span><br><span class="line">MCONTRIBUTING.md</span><br><span class="line">$ git <span class="keyword">status</span></span><br><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></file></p><p>这个命令有点儿奇怪，但是起作用了。 CONTRIBUTING.md 文件已经是修改未暂存的状态了。</p><blockquote><p>Note：虽然在调用时加上 –hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工作目录中所有当前进度丢失！）不加选项地调用 git reset 并不危险 — 它只会修改暂存区域。</p></blockquote><h2 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h2><p>如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p><p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- CONTRIBUTING.md</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure></p><p>可以看到那些修改已经被撤消了。</p><blockquote><p>Important: 你需要知道 git checkout – [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-撤销操作&quot;&gt;&lt;a href=&quot;#Git-撤销操作&quot; class=&quot;headerlink&quot; title=&quot;Git 撤销操作&quot;&gt;&lt;/a&gt;Git 撤销操作&lt;/h1&gt;&lt;p&gt;在任何一个阶段，你都有可能想要撤消某些操作。 注意，有些撤消操作是不可逆的。 这是在使用 G
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>世界以痛吻我 我却报之以歌</title>
    <link href="https://wxzhongwang.github.io/2019/01/29/%E4%B8%96%E7%95%8C%E4%BB%A5%E7%97%9B%E5%90%BB%E6%88%91%EF%BC%8C%E6%88%91%E5%8D%B4%E6%8A%A5%E4%B9%8B%E4%BB%A5%E6%AD%8C/"/>
    <id>https://wxzhongwang.github.io/2019/01/29/世界以痛吻我，我却报之以歌/</id>
    <published>2019-01-29T09:10:10.000Z</published>
    <updated>2019-01-30T08:46:56.649Z</updated>
    
    <content type="html"><![CDATA[<p>今年发生不好的事，一切都显得不那么美好，就很多事情都不按大家的预想在发展。就一起都感觉不顺利，2018已经不够友好了，还记得刚刚过去的23岁生日，记得自己的愿望是希望，真挚希望所有的亲朋好友能够健康，健康就够了，钱多钱少不重要，就是健康就够了。。。</p><p>但是偏偏还是发生了。</p><h1 id="世界以痛吻我-我却报之以歌"><a href="#世界以痛吻我-我却报之以歌" class="headerlink" title="世界以痛吻我 我却报之以歌"></a>世界以痛吻我 我却报之以歌</h1><p>亲人已仙游，未呈儿孙福，幽魂于千里，如何度思量。</p><p>2018年06月14日早9：00点，在杭州，还在床上的我猛的收到了家人群的消息，早已患糖尿病多年的舅舅病逝。尽管心里有多不愿意接受，但是心里也算是做好了准备。在五一回家时间便已经被告知舅舅身体日渐消瘦，骨瘦如柴。我还趁着工作之余，抽空去看望了。当看到那一瞬间，我感觉我整个人就不好了，眼泪一下就出来了，整个人像楞住了一般，久久说不出话，手也不知道往哪里放。当舅舅看到我，一把把我拽住，死死捏着，这一幕到现在我也忘不了…</p><p>又是在杭州，2019年01月29日早8: 00点，同样的戏码，姨夫病逝，癌症晚期，距离收到通知，也就短短三个多月时间，大概一百多天，原本一个看上去健健康康的人，就突然离开，就像上帝给你的人生突然上了锁，然后把钥匙给扔掉了的感觉…</p><p>醒来又是一天，开始干活，累…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年发生不好的事，一切都显得不那么美好，就很多事情都不按大家的预想在发展。就一起都感觉不顺利，2018已经不够友好了，还记得刚刚过去的23岁生日，记得自己的愿望是希望，真挚希望所有的亲朋好友能够健康，健康就够了，钱多钱少不重要，就是健康就够了。。。&lt;/p&gt;
&lt;p&gt;但是偏偏还
      
    
    </summary>
    
      <category term="个人" scheme="https://wxzhongwang.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="个人" scheme="https://wxzhongwang.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Git查看历史提交</title>
    <link href="https://wxzhongwang.github.io/2019/01/25/Git%20%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/"/>
    <id>https://wxzhongwang.github.io/2019/01/25/Git 查看提交历史/</id>
    <published>2019-01-25T03:58:59.671Z</published>
    <updated>2019-01-25T04:06:07.284Z</updated>
    
    <content type="html"><![CDATA[<p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。<br>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><h1 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h1><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。<br>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p>git log 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。</p><h2 id="定制输出格式"><a href="#定制输出格式" class="headerlink" title="定制输出格式"></a>定制输出格式</h2><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p>一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：</p><blockquote><p>该选项除了显示基本信息之外，还附带了每次commit的变化。当进行代码审查，或者快速浏览某个搭档提交的commit所带来的变化的时候，这个参数就非常有用了。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p -<span class="number">2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line"><span class="symbol">Author:</span> Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Mon Mar <span class="number">17</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">11</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..<span class="number">8</span>f94139 <span class="number">100644</span></span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -<span class="number">5</span>,<span class="number">7</span> +<span class="number">5</span>,<span class="number">7</span> @@ <span class="keyword">require</span> <span class="string">'rake/gempackagetask'</span></span><br><span class="line"> spec = <span class="symbol">Gem:</span>:Specification.new <span class="keyword">do</span> |s|</span><br><span class="line">     s.platform  =   <span class="symbol">Gem:</span>:<span class="symbol">Platform:</span>:RUBY</span><br><span class="line">     s.name      =   <span class="string">"simplegit"</span></span><br><span class="line">-    s.version   =   <span class="string">"0.1.0"</span></span><br><span class="line">+    s.version   =   <span class="string">"0.1.1"</span></span><br><span class="line">     s.author    =   <span class="string">"Scott Chacon"</span></span><br><span class="line">     s.email     =   <span class="string">"schacon@gee-mail.com"</span></span><br><span class="line">     s.summary   =   <span class="string">"A simple gem for using Git in Ruby code."</span></span><br><span class="line"></span><br><span class="line">commit <span class="number">085</span>bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line"><span class="symbol">Author:</span> Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Sat Mar <span class="number">15</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">33</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/<span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span> <span class="title">b</span>/<span class="title">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">index a0a60ae..<span class="number">47</span>c6340 <span class="number">100644</span></span><br><span class="line">--- a/<span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">+++ b/<span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">@@ -<span class="number">18</span>,<span class="number">8</span> +<span class="number">18</span>,<span class="number">3</span> @@ <span class="class"><span class="keyword">class</span> <span class="title">SimpleGit</span></span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">-</span><br><span class="line">-<span class="keyword">if</span> $<span class="number">0</span> == <span class="keyword">__FILE__</span></span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-<span class="keyword">end</span></span><br><span class="line">\ No newline at <span class="keyword">end</span> <span class="keyword">of</span> file</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="–stat"><a href="#–stat" class="headerlink" title="–stat"></a>–stat</h3><p>你也可以为 git log 附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用 –stat 选项：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line"><span class="symbol">Author:</span> Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Mon Mar <span class="number">17</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">11</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile | <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br><span class="line"></span><br><span class="line">commit <span class="number">085</span>bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line"><span class="symbol">Author:</span> Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Sat Mar <span class="number">15</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">33</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span> | 5 -----</span></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">5</span> deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line"><span class="symbol">Author:</span> Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line"><span class="symbol">Date:</span>   Sat Mar <span class="number">15</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">28</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  <span class="number">6</span> ++++++</span><br><span class="line"> Rakefile         | <span class="number">23</span> +++++++++++++++++++++++</span><br><span class="line"> <span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span> | 25 +++++++++++++++++++++++++</span></span><br><span class="line"> <span class="number">3</span> files changed, <span class="number">54</span> insertions(+)</span><br></pre></td></tr></table></figure></p><blockquote><p>正如你所看到的，–stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p></blockquote><h3 id="–pretty"><a href="#–pretty" class="headerlink" title="–pretty"></a>–pretty</h3><blockquote><p>这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed <span class="keyword">the</span> <span class="built_in">version</span> <span class="built_in">number</span></span><br><span class="line"><span class="number">085</span>bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 <span class="keyword">first</span> commit</span><br></pre></td></tr></table></figure></p></blockquote><p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用。因为你知道输出的格式不会随着 Git 的更新而发生改变：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--pretty=format:"%h - %an, %ar : %s"</span></span><br><span class="line">ca82a6d - Scott Chacon, <span class="number">6</span> years ago : changed <span class="keyword">the</span> <span class="built_in">version</span> <span class="built_in">number</span></span><br><span class="line"><span class="number">085</span>bb3b - Scott Chacon, <span class="number">6</span> years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, <span class="number">6</span> years ago : <span class="keyword">first</span> commit</span><br></pre></td></tr></table></figure></p><p>git log –pretty=format 常用的选项 列出了常用的格式占位符写法及其代表的意义。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者（committer）的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><blockquote><p>你一定奇怪 作者 和 提交者之间究竟有何差别，其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。</p></blockquote><h3 id="–graph"><a href="#–graph" class="headerlink" title="–graph"></a>–graph</h3><p>当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--pretty=format:"%h %s" --graph</span></span><br><span class="line">* <span class="number">2</span>d3acf9 ignore errors <span class="built_in">from</span> SIGCHLD <span class="keyword">on</span> <span class="title">trap</span></span><br><span class="line">*  <span class="number">5e3</span>ee11 Merge branch <span class="string">'master'</span> <span class="keyword">of</span> git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * <span class="number">420</span>eac9 Added <span class="keyword">a</span> method <span class="keyword">for</span> getting <span class="keyword">the</span> current branch.</span><br><span class="line">* | <span class="number">30e367</span>c timeout code <span class="keyword">and</span> tests</span><br><span class="line">* | <span class="number">5</span>a09431 <span class="built_in">add</span> timeout protection <span class="built_in">to</span> grit</span><br><span class="line">* | e1193f8 support <span class="keyword">for</span> heads <span class="keyword">with</span> slashes <span class="keyword">in</span> them</span><br><span class="line">|/</span><br><span class="line">* d6016bc <span class="built_in">require</span> <span class="built_in">time</span> <span class="keyword">for</span> xmlschema</span><br><span class="line">*  <span class="number">11</span>d191e Merge branch <span class="string">'defunkt'</span> <span class="keyword">into</span> <span class="built_in">local</span></span><br></pre></td></tr></table></figure></p><h3 id="常用汇总"><a href="#常用汇总" class="headerlink" title="常用汇总"></a>常用汇总</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td>–stat</td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td>–name-only</td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td>–name-status</td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td>–abbrev-commit</td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td>–relative-date</td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td>–graph</td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td>–pretty</td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><h2 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h2><p>it log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 -2 了，它只显示最近的两条提交， 实际上，这是 -<n> 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。 不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</n></p><h3 id="常用汇总-1"><a href="#常用汇总-1" class="headerlink" title="常用汇总"></a>常用汇总</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-(n)</td><td>仅显示最近的 n 条提交。</td></tr><tr><td>–since, –after</td><td>仅显示指定时间之后的提交。</td></tr><tr><td>–until, –before</td><td>仅显示指定时间之前的提交。</td></tr><tr><td>–author</td><td>仅显示指定作者相关的提交。</td></tr><tr><td>–committer</td><td>仅显示指定提交者相关的提交。</td></tr><tr><td>–grep</td><td>仅显示含指定关键字的提交。</td></tr><tr><td>-S</td><td>仅显示添加或移除了某个关键字的提交。</td></tr></tbody></table><p>另外还有按照时间作限制的选项，比如 –since 和 –until 也很有用。 例如，下面的命令列出所有最近两周内的提交：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--since=2.weeks</span></span><br></pre></td></tr></table></figure></p><p>这个命令可以在多种格式下工作，比如说具体的某一天 “2008-01-15”，或者是相对地多久以前 “2 years 1 day 3 minutes ago”。</p><p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> --pretty=<span class="string">"%h - %s"</span> --author=gitster --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">   --before=<span class="string">"2008-11-01"</span> --<span class="keyword">no</span>-merges -- t/</span><br><span class="line"><span class="number">5610</span>e3b - Fix testcase failure <span class="keyword">when</span> extended attributes are in <span class="keyword">use</span></span><br><span class="line">acd3b9e - Enhance hold_lock_file_for<span class="number">_</span>&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic <span class="keyword">link</span> HEAD</span><br><span class="line">d1a43f2 - <span class="keyword">reset</span> --hard/<span class="keyword">read</span>-tree --<span class="keyword">reset</span> -u: remove unmerged new paths</span><br><span class="line"><span class="number">51</span>a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detached HEAD</span><br><span class="line">b0ad11e - pull: allow <span class="string">"git pull origin $something:$current_branch"</span> into an unborn branch</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。&lt;br&gt;默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git移动文件</title>
    <link href="https://wxzhongwang.github.io/2019/01/25/Git%20%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6/"/>
    <id>https://wxzhongwang.github.io/2019/01/25/Git 移动文件/</id>
    <published>2019-01-25T03:58:56.881Z</published>
    <updated>2019-01-25T04:06:13.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h1><p>Git 并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么。</p><p>既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">mv</span> file_from file_to</span><br></pre></td></tr></table></figure></p><p>它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git mv README.md README</span><br><span class="line"><span class="variable">$ </span>git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be <span class="symbol">committed:</span></span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    <span class="symbol">renamed:</span>    README.md -&gt; README</span><br></pre></td></tr></table></figure></p><p>其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README<span class="selector-class">.md</span> README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure></p><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，mv 是一条命令而另一种方式需要三条命令，直接用 git mv 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动文件&quot;&gt;&lt;a href=&quot;#移动文件&quot; class=&quot;headerlink&quot; title=&quot;移动文件&quot;&gt;&lt;/a&gt;移动文件&lt;/h1&gt;&lt;p&gt;Git 并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 G
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git移除文件</title>
    <link href="https://wxzhongwang.github.io/2019/01/25/Git%20%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6/"/>
    <id>https://wxzhongwang.github.io/2019/01/25/Git 移除文件/</id>
    <published>2019-01-25T03:58:53.780Z</published>
    <updated>2019-01-25T04:06:16.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date <span class="keyword">with</span> <span class="string">'origin/master'</span>.</span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p><p>然后再运行 git rm 记录此次移除文件的操作：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm <span class="symbol">'PROJECTS</span>.md'</span><br><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure></p><p>下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从Git仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆.a这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="comment">--cached README</span></span><br></pre></td></tr></table></figure></p><p>git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git rm <span class="built-in">log</span>/\*.<span class="built-in">log</span></span><br></pre></td></tr></table></figure></p><p>注意到星号 * 之前的反斜杠 \， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git rm \*~</span><br></pre></td></tr></table></figure></p><p>该命令为删除以 ~ 结尾的所有文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-rm&quot;&gt;&lt;a href=&quot;#git-rm&quot; class=&quot;headerlink&quot; title=&quot;git rm&quot;&gt;&lt;/a&gt;git rm&lt;/h1&gt;&lt;p&gt;要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git提交</title>
    <link href="https://wxzhongwang.github.io/2019/01/25/Git%20Commit/"/>
    <id>https://wxzhongwang.github.io/2019/01/25/Git Commit/</id>
    <published>2019-01-25T03:58:48.533Z</published>
    <updated>2019-01-25T04:05:40.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h1><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit</span><br></pre></td></tr></table></figure></p><p>你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p><blockquote><p>请在每次提交时添加comment<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"Story 182: Fix benchmarks for speed"</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">463</span>dc4f] Story <span class="number">182</span>: Fix benchmarks <span class="keyword">for</span> speed</span><br><span class="line"> <span class="number">2</span> files <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> README</span><br></pre></td></tr></table></figure></p></blockquote><p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><blockquote><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p></blockquote><h2 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h2><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br><span class="line">$ git <span class="keyword">commit</span> -a -m <span class="string">'added new benchmarks'</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">83e38</span>c7] added <span class="keyword">new</span> benchmarks</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">5</span> insertions(+), <span class="number">0</span> deletions(-)</span><br></pre></td></tr></table></figure></p><p>此时，提交之前不再需要 git add 文件“CONTRIBUTING.md”了。个人觉得不推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-Commit&quot;&gt;&lt;a href=&quot;#Git-Commit&quot; class=&quot;headerlink&quot; title=&quot;Git Commit&quot;&gt;&lt;/a&gt;Git Commit&lt;/h1&gt;&lt;p&gt;现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git Diff</title>
    <link href="https://wxzhongwang.github.io/2019/01/24/Git%20Diff/"/>
    <id>https://wxzhongwang.github.io/2019/01/24/Git Diff/</id>
    <published>2019-01-24T08:08:56.227Z</published>
    <updated>2019-01-25T03:59:24.007Z</updated>
    
    <content type="html"><![CDATA[<p>#Git Diff</p><p>如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。 尽管 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，git diff 将通过文件补丁的格式显示具体哪些行发生了改变。</p><p>作用<br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变。化内容。</p><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）</p><p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Git Diff&lt;/p&gt;
&lt;p&gt;如果 git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。 尽管 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，git diff 将通过文件补丁的格式显示
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git .gitignore</title>
    <link href="https://wxzhongwang.github.io/2019/01/24/Git%20gitignore/"/>
    <id>https://wxzhongwang.github.io/2019/01/24/Git gitignore/</id>
    <published>2019-01-24T08:08:53.509Z</published>
    <updated>2019-01-24T08:11:41.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore 忽略文件"></a>.gitignore 忽略文件</h1><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> cat .gitignore</span><br><span class="line"><span class="comment">*.[oa]</span></span><br><span class="line"><span class="comment">*~</span></span><br></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 </p><blockquote><p>要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p></blockquote><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（/）开头防止递归。</li><li>匹配模式可以以（/）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<em>）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（</em>) 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 a/z, a/b/z 或 <code>a/b/c/z</code>等。</p><p>我们再看一个 .gitignore 文件的例子：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># but do track lib.a, even though you're ignoring .a files above</span></span><br><span class="line">!<span class="class"><span class="keyword">lib</span>.<span class="title">a</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**<span class="regexp">/*.pdf</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gitignore-忽略文件&quot;&gt;&lt;a href=&quot;#gitignore-忽略文件&quot; class=&quot;headerlink&quot; title=&quot;.gitignore 忽略文件&quot;&gt;&lt;/a&gt;.gitignore 忽略文件&lt;/h1&gt;&lt;p&gt;一般我们总会有些文件无需纳入 Git 的
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git记录更新到仓库</title>
    <link href="https://wxzhongwang.github.io/2019/01/24/Git%20%E5%9F%BA%E7%A1%80%20-%20%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93/"/>
    <id>https://wxzhongwang.github.io/2019/01/24/Git 基础 - 记录每次更新到仓库/</id>
    <published>2019-01-24T08:08:50.299Z</published>
    <updated>2019-01-25T04:05:55.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h1><p>现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。 接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><blockquote><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</p></blockquote><p>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：</p><p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="image"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">检查当前文件状态:</span><br><span class="line">$ git status</span><br><span class="line">On branch <span class="literal">master</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。</p><p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">echo</span> <span class="string">'My Project'</span> &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added <span class="keyword">to</span> commit but untracked <span class="keyword">files</span> present (use <span class="string">"git add"</span> <span class="keyword">to</span> track)</span><br></pre></td></tr></table></figure></p><p>在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用命令 git <span class="keyword">add</span><span class="bash"> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</span></span><br><span class="line"><span class="bash">$ git add README</span></span><br></pre></td></tr></table></figure></p><p>这时候我们在运行git status查看状态：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">file</span>:   README</span><br></pre></td></tr></table></figure></p><p>文件已经处于被追踪的状态了，并处于暂存状态。</p><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">file</span>:   README</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p><blockquote><p>文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add命令。</p></blockquote><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add:"></a>git add:</h2><blockquote><p>这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 git add 将”CONTRIBUTING.md”放到暂存区，然后再看看 git status 的输出：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">file</span>:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p></blockquote><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vim CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">file</span>:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p><p>怎么回事？ 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本， 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">file</span>:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></p><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>git status 命令的输出十分详细，但其用语有些繁琐。 如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出。 运行 git status -s ，状态报告输出如下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  <span class="class"><span class="keyword">lib</span>/<span class="title">git</span>.<span class="title">rb</span></span></span><br><span class="line">M  <span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure></p><p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录每次更新到仓库&quot;&gt;&lt;a href=&quot;#记录每次更新到仓库&quot; class=&quot;headerlink&quot; title=&quot;记录每次更新到仓库&quot;&gt;&lt;/a&gt;记录每次更新到仓库&lt;/h1&gt;&lt;p&gt;现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git Clone</title>
    <link href="https://wxzhongwang.github.io/2019/01/24/Git%20%E8%8E%B7%E5%8F%96Git%E4%BB%93%E5%BA%93/"/>
    <id>https://wxzhongwang.github.io/2019/01/24/Git 获取Git仓库/</id>
    <published>2019-01-24T08:08:46.776Z</published>
    <updated>2019-01-24T08:11:05.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h1><p>有两种取得 Git 项目仓库的方法。 </p><ul><li>第一种是在现有项目或目录下导入所有文件到 Git 中</li><li>第二种是从一个服务器克隆一个现有的 Git 仓库</li></ul><h2 id="在现有目录初始化"><a href="#在现有目录初始化" class="headerlink" title="在现有目录初始化"></a>在现有目录初始化</h2> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure><blockquote><p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p></blockquote><h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p> 如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。 </p><p> 克隆仓库的命令格式是 git clone [url] 。</p> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone git<span class="variable">@172</span>.<span class="number">16.5</span>.<span class="number">77</span><span class="symbol">:shengwangzhong/hexo-blog</span>.git</span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 “hexo-blog” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的hexo-blog文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：<br> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone git<span class="variable">@172</span>.<span class="number">16.5</span>.<span class="number">77</span><span class="symbol">:shengwangzhong/hexo-blog</span>.git your-folder-name</span><br></pre></td></tr></table></figure></p><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 your-folder-name。</p><p> Git 支持多种数据传输协议。 ssh\https\git</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取-Git-仓库&quot;&gt;&lt;a href=&quot;#获取-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;获取 Git 仓库&quot;&gt;&lt;/a&gt;获取 Git 仓库&lt;/h1&gt;&lt;p&gt;有两种取得 Git 项目仓库的方法。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是在现有项目
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
