<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼有点闲</title>
  
  <subtitle>Dick</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wxzhongwang.github.io/"/>
  <updated>2019-01-08T06:36:16.053Z</updated>
  <id>https://wxzhongwang.github.io/</id>
  
  <author>
    <name>Dick Zhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis和Memcached比较</title>
    <link href="https://wxzhongwang.github.io/2019/01/08/Redis%E5%92%8CMemcached%E6%AF%94%E8%BE%83/"/>
    <id>https://wxzhongwang.github.io/2019/01/08/Redis和Memcached比较/</id>
    <published>2019-01-08T06:33:59.000Z</published>
    <updated>2019-01-08T06:36:16.053Z</updated>
    
    <content type="html"><![CDATA[<p>Redis和Memcache都是将数据存放在内存中，都是内存数据库。本文介绍两者的区别。</p><h1 id="Redis和Memcached比较"><a href="#Redis和Memcached比较" class="headerlink" title="Redis和Memcached比较"></a>Redis和Memcached比较</h1><ul><li><p>Memcached是多线程，而Redis使用单线程.</p></li><li><p>Memcached使用预分配的内存池的方式，Redis使用现场申请内存的方式来存储数据，并且可以配置虚拟内存。</p></li><li><p>Redis可以实现持久化，主从复制，实现故障恢复。</p></li><li><p>Memcached只是简单的key与value,但是Redis支持数据类型比较多。</p></li></ul><p>Redis的存储分为内存存储、磁盘存储 .从这一点，也说明了Redis与Memcached是有区别的。Redis 与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改 操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis有两种存储方式(默认:snapshot)</p><ol><li>snapshot<blockquote><p>实现方法是定时将内存的快照(snapshot)持久化到硬盘，<br>这种方法缺点是持久化之后如果出现crash则会丢失一段数据。<br>因此在完美主义者的推动下作者增加了aof方式。</p></blockquote></li></ol><ol start="2"><li>aof<blockquote><p>即append only mode，在写入内存数据的同时将操作命令保存到日志文件，在一个并发更改上万的系统中，命令日志是一个非常庞大的数据，管理维护成本非常高，恢复重建时间会非常长，这样导致失去aof高可用性本意。另外更重要的是Redis是一个内存数据结构模型，所有的优势都是建立在对内存复杂数据结构高效的原子操作</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis和Memcache都是将数据存放在内存中，都是内存数据库。本文介绍两者的区别。&lt;/p&gt;
&lt;h1 id=&quot;Redis和Memcached比较&quot;&gt;&lt;a href=&quot;#Redis和Memcached比较&quot; class=&quot;headerlink&quot; title=&quot;Redis和
      
    
    </summary>
    
      <category term="Redis" scheme="https://wxzhongwang.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://wxzhongwang.github.io/tags/Redis/"/>
    
      <category term="NOSQL" scheme="https://wxzhongwang.github.io/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://wxzhongwang.github.io/2019/01/08/Redis%E7%AE%80%E4%BB%8B/"/>
    <id>https://wxzhongwang.github.io/2019/01/08/Redis简介/</id>
    <published>2019-01-08T06:31:13.000Z</published>
    <updated>2019-01-08T06:32:04.017Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一个开源的，使用C语言编写，面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。Redis纯粹为应用而产生，它是一个高性能的key-value数据库,并且提供了多种语言的API，性能测试结果表示SET操作每秒钟可达110000次，GET操作每秒81000次（当然不同的服务器配置性能不同）。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis是一个开源的，使用C语言编写，面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。Redis纯粹为应用而产生，它是一个高性能的key-value数据库,并且提供了多种语言的API，性能测试结果表示SET操作每秒钟可达110000次，GET操作每秒81000次（当然不同的服务器配置性能不同）。</p><p>Redis目前提供五种数据类型：</p><ul><li>string(字符串),</li><li>list（链表）, </li><li>Hash（哈希）,</li><li>set（集合）,</li><li>zset(sorted set)  （有序集合）</li></ul><p>Redis开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。</p><p>Redis可以做消息队列？</p><blockquote><p>首先，redis设计用来做缓存的，但是由于它自身的某种特性使得它可以用来做消息队列，它有几个阻塞式的API可以使用，正是这些阻塞式的API让其有能力做消息队列；另外，做消息队列的其他特性例如FIFO（先入先出）也很容易实现，只需要一个list对象从头取数据，从尾部塞数据即可；redis能做消息队列还得益于其list对象blpop brpop接口以及Pub/Sub（发布/订阅）的某些接口，它们都是阻塞版的，所以可以用来做消息队列。</p></blockquote><p>对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。<br>实验表明：</p><blockquote><p>入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍<br>受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis是一个开源的，使用C语言编写，面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。Redis纯粹为应用而产生，它是一个高性能的key-value数据库,并且提供了多种语言的API，性能测试结果表示SET操作每秒钟可达
      
    
    </summary>
    
      <category term="Redis" scheme="https://wxzhongwang.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://wxzhongwang.github.io/tags/Redis/"/>
    
      <category term="消息队列" scheme="https://wxzhongwang.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Git使用中的问题</title>
    <link href="https://wxzhongwang.github.io/2019/01/08/Git%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wxzhongwang.github.io/2019/01/08/Git使用中的问题/</id>
    <published>2019-01-08T06:18:02.000Z</published>
    <updated>2019-01-08T06:29:58.885Z</updated>
    
    <content type="html"><![CDATA[<p>git push失败 fatal: Could not read from remote repository</p><h2 id="阐述问题"><a href="#阐述问题" class="headerlink" title="阐述问题"></a>阐述问题</h2><p>git push失败 fatal: Could not read from remote repository. 因为仓库地址不对。更改地址就可以push了。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">$ git remote <span class="built_in">set</span>-url origin XXX</span><br></pre></td></tr></table></figure><h2 id="服务器上的-Git-生成-SSH-公钥"><a href="#服务器上的-Git-生成-SSH-公钥" class="headerlink" title="服务器上的 Git - 生成 SSH 公钥"></a>服务器上的 Git - 生成 SSH 公钥</h2><h3 id="生成-SSH-公钥"><a href="#生成-SSH-公钥" class="headerlink" title="生成 SSH 公钥"></a>生成 SSH 公钥</h3><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。<br>若想在github中使用的话需要将公钥复制到github&gt;setting&gt;SSH and GPG keys中添加ssh keys。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生成钥匙</span><br><span class="line">$ ssh-keygen</span><br><span class="line">查看公钥</span><br><span class="line"><span class="variable">$cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git push失败 fatal: Could not read from remote repository&lt;/p&gt;
&lt;h2 id=&quot;阐述问题&quot;&gt;&lt;a href=&quot;#阐述问题&quot; class=&quot;headerlink&quot; title=&quot;阐述问题&quot;&gt;&lt;/a&gt;阐述问题&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="版本控制工具" scheme="https://wxzhongwang.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>HttpStatusCode</title>
    <link href="https://wxzhongwang.github.io/2019/01/08/HttpStatusCode/"/>
    <id>https://wxzhongwang.github.io/2019/01/08/HttpStatusCode/</id>
    <published>2019-01-08T06:18:02.000Z</published>
    <updated>2019-01-09T01:53:14.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HttpStatusCode"><a href="#HttpStatusCode" class="headerlink" title="HttpStatusCode"></a>HttpStatusCode</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1xx：相关信息</span></span><br><span class="line"><span class="comment">    2xx：操作成功</span></span><br><span class="line"><span class="comment">    3xx：重定向</span></span><br><span class="line"><span class="comment">    4xx：客户端错误</span></span><br><span class="line"><span class="comment">    5xx：服务器错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:left">状态码</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">Continue</td><td style="text-align:left">100</td><td style="text-align:left">指示客户端可能继续其请求。</td></tr><tr><td style="text-align:center">SwitchingProtocols</td><td style="text-align:left">100</td><td style="text-align:left">指示正在更改协议版本或协议。</td></tr><tr><td style="text-align:center">OK</td><td style="text-align:left">200</td><td style="text-align:left">指示请求成功，且请求的信息包含在响应中。</td></tr><tr><td style="text-align:center">Created</td><td style="text-align:left">201</td><td style="text-align:left">指示请求导致在响应被发送前创建新资源。</td></tr><tr><td style="text-align:center">Accepted</td><td style="text-align:left">202</td><td style="text-align:left">指示请求已被接受做进一步处理。</td></tr><tr><td style="text-align:center">NonAuthoritativeInformation</td><td style="text-align:left">202</td><td style="text-align:left">指示返回的元信息来自缓存副本而不是原始服务器，因此可能不正确。</td></tr><tr><td style="text-align:center">NoContent</td><td style="text-align:left">204</td><td style="text-align:left">指示请求成功，指示已成功处理请求并且响应已被设定为无内容。</td></tr><tr><td style="text-align:center">ResetContent</td><td style="text-align:left">205</td><td style="text-align:left">指示客户端应重置（或重新加载）当前资源。</td></tr><tr><td style="text-align:center">PartialContent</td><td style="text-align:left">206</td><td style="text-align:left">指示响应是包括字节范围的 GET 请求所请求的部分响应。</td></tr><tr><td style="text-align:center">MultipleChoices</td><td style="text-align:left">300</td><td style="text-align:left">指示请求的信息有多种表示形式，默认操作是将此状态视为重定向，并遵循与此响应关联的 Location 头的内容。</td></tr><tr><td style="text-align:center">Ambiguous</td><td style="text-align:left">300</td><td style="text-align:left">指示请求的信息有多种表示形式。默认操作是将此状态视为重定向，并遵循与此响应关联的 Location 头的内容。</td></tr><tr><td style="text-align:center">MovedPermanently</td><td style="text-align:left">301</td><td style="text-align:left">指示请求的信息已移到 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。</td></tr><tr><td style="text-align:center">Moved</td><td style="text-align:left">301</td><td style="text-align:left">指示请求的信息已移到 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求将使用 GET 方法。</td></tr><tr><td style="text-align:center">Found</td><td style="text-align:left">302</td><td style="text-align:left">指示请求的信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求将使用 GET 方法。</td></tr><tr><td style="text-align:center">Redirect</td><td style="text-align:left">302</td><td style="text-align:left">指示请求的信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求将使用 GET 方法。</td></tr><tr><td style="text-align:center">SeeOther</td><td style="text-align:left">303</td><td style="text-align:left">作为 POST 的结果，SeeOther 将客户端自动重定向到 Location 头中指定的 URI。用 GET 生成对 Location 头所指定的资源的请求。</td></tr><tr><td style="text-align:center">RedirectMethod</td><td style="text-align:left">303</td><td style="text-align:left">作为 POST 的结果，RedirectMethod 将客户端自动重定向到 Location 头中指定的 URI。用 GET 生成对 Location 头所指定的资源的请求。</td></tr><tr><td style="text-align:center">NotModified</td><td style="text-align:left">304</td><td style="text-align:left">指示客户端的缓存副本是最新的。未传输此资源的内容。</td></tr><tr><td style="text-align:center">UseProxy</td><td style="text-align:left">305</td><td style="text-align:left">指示请求应使用位于 Location 头中指定的 URI 的代理服务器。</td></tr><tr><td style="text-align:center">Unused</td><td style="text-align:left">306</td><td style="text-align:left">是未完全指定的 HTTP/1.1 规范的建议扩展。</td></tr><tr><td style="text-align:center">TemporaryRedirect</td><td style="text-align:left">307</td><td style="text-align:left">指示请求信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求还将使用 POST 方法。</td></tr><tr><td style="text-align:center">RedirectKeepVerb</td><td style="text-align:left">307</td><td style="text-align:left">指示请求信息位于 Location 头中指定的 URI 处。接收到此状态时的默认操作为遵循与响应关联的 Location 头。原始请求方法为 POST 时，重定向的请求还将使用 POST 方法。</td></tr><tr><td style="text-align:center">BadRequest</td><td style="text-align:left">400</td><td style="text-align:left">指示服务器未能识别请求。如果没有其他适用的错误，或者如果不知道准确的错误或错误没有自己的错误代码，则发送 BadRequest。</td></tr><tr><td style="text-align:center">Unauthorized</td><td style="text-align:left">401</td><td style="text-align:left">指示请求的资源要求身份验证。WWW-Authenticate头包含如何执行身份验证的详细信息。</td></tr><tr><td style="text-align:center">PaymentRequired</td><td style="text-align:left">402</td><td style="text-align:left">保留 PaymentRequired 以供将来使用。</td></tr><tr><td style="text-align:center">Forbidden</td><td style="text-align:left">403</td><td style="text-align:left">指示服务器拒绝满足请求。</td></tr><tr><td style="text-align:center">NotFound</td><td style="text-align:left">404</td><td style="text-align:left">指示请求的资源不在服务器上。</td></tr><tr><td style="text-align:center">MethodNotAllowed</td><td style="text-align:left">405</td><td style="text-align:left">指示请求的资源上不允许请求方法（POST 或 GET）。</td></tr><tr><td style="text-align:center">NotAcceptable</td><td style="text-align:left">406</td><td style="text-align:left">指示客户端已用 Accept 头指示将不接受资源的任何可用表示形式。</td></tr><tr><td style="text-align:center">ProxyAuthenticationRequired</td><td style="text-align:left">407</td><td style="text-align:left">指示请求的代理要求身份验证。Proxy-authenticate 头包含如何执行身份验证的详细信息。</td></tr><tr><td style="text-align:center">RequestTimeout</td><td style="text-align:left">408</td><td style="text-align:left">指示客户端没有在服务器期望请求的时间内发送请求。</td></tr><tr><td style="text-align:center">Conflict</td><td style="text-align:left">409</td><td style="text-align:left">指示由于服务器上的冲突而未能执行请求。</td></tr><tr><td style="text-align:center">Gone</td><td style="text-align:left">410</td><td style="text-align:left">指示请求的资源不再可用。</td></tr><tr><td style="text-align:center">LengthRequired</td><td style="text-align:left">411</td><td style="text-align:left">指示缺少必需的 Content-length 头。</td></tr><tr><td style="text-align:center">PreconditionFailed</td><td style="text-align:left">412</td><td style="text-align:left">指示为此请求设置的条件失败，且无法执行此请求。条件是用条件请求标头（如 If-Match、If-None-Match 或 If-Unmodified-Since）设置的。</td></tr><tr><td style="text-align:center">RequestEntityTooLarge</td><td style="text-align:left">413</td><td style="text-align:left">指示请求太大，服务器无法处理。</td></tr><tr><td style="text-align:center">RequestUriTooLong</td><td style="text-align:left">414</td><td style="text-align:left">指示 URI 太长。</td></tr><tr><td style="text-align:center">UnsupportedMediaType</td><td style="text-align:left">415</td><td style="text-align:left">指示请求是不支持的类型。</td></tr><tr><td style="text-align:center">RequestedRangeNotSatisfiable</td><td style="text-align:left">416</td><td style="text-align:left">RequestedRangeNotSatisfiable指示无法返回从资源请求的数据范围，因为范围的开头在资源的开头之前，或因为范围的结尾在资源的结尾之后。</td></tr><tr><td style="text-align:center">ExpectationFailed</td><td style="text-align:left">417</td><td style="text-align:left">指示服务器未能符合 Expect 头中给定的预期值。</td></tr><tr><td style="text-align:center">UpgradeRequired</td><td style="text-align:left">426</td><td style="text-align:left">客户端应当切换到TLS/1.0</td></tr><tr><td style="text-align:center">InternalServerError</td><td style="text-align:left">500</td><td style="text-align:left">指示服务器上发生了一般错误。</td></tr><tr><td style="text-align:center">NotImplemented</td><td style="text-align:left">501</td><td style="text-align:left">指示服务器不支持请求的函数。</td></tr><tr><td style="text-align:center">BadGateway</td><td style="text-align:left">502</td><td style="text-align:left">指示中间代理服务器从另一代理或原始服务器接收到错误响应。</td></tr><tr><td style="text-align:center">ServiceUnavailable</td><td style="text-align:left">503</td><td style="text-align:left">指示服务器暂时不可用，通常是由于过多加载或维护。</td></tr><tr><td style="text-align:center">GatewayTimeout</td><td style="text-align:left">504</td><td style="text-align:left">指示中间代理服务器在等待来自另一个代理或原始服务器的响应时已超时。</td></tr><tr><td style="text-align:center">HttpVersionNotSupported</td><td style="text-align:left">505</td><td style="text-align:left">指示服务器不支持请求的 HTTP 版本。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HttpStatusCode&quot;&gt;&lt;a href=&quot;#HttpStatusCode&quot; class=&quot;headerlink&quot; title=&quot;HttpStatusCode&quot;&gt;&lt;/a&gt;HttpStatusCode&lt;/h1&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="前端" scheme="https://wxzhongwang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Web" scheme="https://wxzhongwang.github.io/tags/Web/"/>
    
      <category term="前端" scheme="https://wxzhongwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>你好，世界</title>
    <link href="https://wxzhongwang.github.io/2018/08/31/hello-world/"/>
    <id>https://wxzhongwang.github.io/2018/08/31/hello-world/</id>
    <published>2018-08-31T09:54:54.000Z</published>
    <updated>2019-01-08T06:12:54.428Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="博客搭建" scheme="https://wxzhongwang.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="前端" scheme="https://wxzhongwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="博客系统" scheme="https://wxzhongwang.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
